using System;
using System.Net.Http;
using System.Text;
using System.Threading.Tasks;

namespace APICallWithOAuth
{
    class Program
    {
        static async Task Main(string[] args)
        {
            // OAuth 2.0 Token endpoint
            string tokenUrl = "https://your-auth-server.com/token";
            string clientId = "your-client-id";
            string clientSecret = "your-client-secret";

            // API endpoint that requires OAuth 2.0 Token
            string apiUrl = "https://your-api-server.com/your-post-endpoint";

            // Fetch OAuth token
            var token = await GetOAuthToken(tokenUrl, clientId, clientSecret);

            if (token != null)
            {
                // Call the API using the token
                var result = await PostRequest(apiUrl, token);
                Console.WriteLine(result);
            }
        }

        // Get OAuth 2.0 Token
        static async Task<string> GetOAuthToken(string tokenUrl, string clientId, string clientSecret)
        {
            using (var client = new HttpClient())
            {
                var request = new HttpRequestMessage(HttpMethod.Post, tokenUrl);
                
                // Prepare the request body (depending on the grant type you are using)
                var body = new StringContent($"client_id={clientId}&client_secret={clientSecret}&grant_type=client_credentials", 
                                             Encoding.UTF8, 
                                             "application/x-www-form-urlencoded");

                request.Content = body;

                var response = await client.SendAsync(request);

                if (response.IsSuccessStatusCode)
                {
                    var tokenResponse = await response.Content.ReadAsStringAsync();

                    // Assuming the token response is JSON
                    // {"access_token": "your_access_token", "expires_in": 3600, ...}
                    dynamic jsonResponse = Newtonsoft.Json.JsonConvert.DeserializeObject(tokenResponse);
                    return jsonResponse.access_token;
                }
                else
                {
                    Console.WriteLine("Failed to get OAuth token");
                    return null;
                }
            }
        }

        // Make a POST request with the token in the Authorization header
        static async Task<string> PostRequest(string apiUrl, string token)
        {
            using (var client = new HttpClient())
            {
                var request = new HttpRequestMessage(HttpMethod.Post, apiUrl);

                // Set the Authorization header
                request.Headers.Add("Authorization", $"Bearer {token}");

                // Prepare JSON body
                var jsonBody = "{\"key1\": \"value1\", \"key2\": \"value2\"}"; // Replace with your actual JSON payload
                request.Content = new StringContent(jsonBody, Encoding.UTF8, "application/json");

                var response = await client.SendAsync(request);

                if (response.IsSuccessStatusCode)
                {
                    return await response.Content.ReadAsStringAsync();
                }
                else
                {
                    return $"Error: {response.StatusCode}";
                }
            }
        }
    }
}
------------------------222222-----------
Sure! Here's a more optimized version for GitHub Copilot:

### Instructions for Improving and Creating Code and Tests
1. **Optimize performance**:
   - Refactor inefficient algorithms.
   - Minimize memory usage.
   - Use appropriate data structures.

2. **Enhance readability**:
   - Follow consistent naming conventions.
   - Document code with meaningful comments.
   - Break down complex methods into smaller functions.

3. **Implement error handling**:
   - Add exception handling for runtime errors.
   - Catch and log all possible exceptions.
   - Validate inputs to prevent unexpected behavior.

4. **Maintain code consistency**:
   - Adhere to coding standards and best practices.
   - Use consistent indentation and formatting.
   - Remove dead code and unused variables.

5. **Increase test coverage**:
   - Write unit tests for all critical functions and edge cases.
   - Validate one behavior or functionality per test.
   - Use parameterized tests for multiple scenarios.

6. **Improve test readability**:
   - Use descriptive names for test methods.
   - Organize tests logically.
   - Add comments explaining test purposes and expected outcomes.

7. **Ensure test reliability**:
   - Avoid hardcoding test data.
   - Mock dependencies to isolate tested code.
   - Ensure tests are independent and can run in any order.

8. **Automate testing**:
   - Integrate unit tests into the CI/CD pipeline.
   - Monitor and address test failures promptly.
   - Keep test suite up-to-date with codebase changes.

### Improving Code Instructions
1. **Optimize Performance**:
   - Refactor inefficient algorithms.
   - Minimize memory usage.
   - Use appropriate data structures.

2. **Enhance Readability**:
   - Follow consistent naming conventions.
   - Document code with meaningful comments.
   - Break down complex methods into smaller functions.

3. **Implement Error Handling**:
   - Add exception handling for runtime errors.
   - Catch and log all possible exceptions.
   - Validate inputs to prevent unexpected behavior.

4. **Maintain Code Consistency**:
   - Adhere to coding standards and best practices.
   - Use consistent indentation and formatting.
   - Remove dead code and unused variables.

### Improving Test Instructions
1. **Increase Test Coverage**:
   - Write unit tests for all critical functions and edge cases.
   - Validate one behavior or functionality per test.
   - Use parameterized tests for multiple scenarios.

2. **Improve Test Readability**:
   - Use descriptive names for test methods.
   - Organize tests logically.
   - Add comments explaining test purposes and expected outcomes.

3. **Ensure Test Reliability**:
   - Avoid hardcoding test data.
   - Mock dependencies to isolate tested code.
   - Ensure tests are independent and can run in any order.

4. **Automate Testing**:
   - Integrate unit tests into the CI/CD pipeline.
   - Monitor and address test failures promptly.
   - Keep test suite up-to-date with codebase changes.

I hope this helps! Let me know if you need any further assistance or specific examples.
